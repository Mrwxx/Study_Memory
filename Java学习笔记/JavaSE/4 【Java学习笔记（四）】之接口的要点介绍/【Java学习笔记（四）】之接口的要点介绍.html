<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>【Java学习笔记（四）】之接口的要点介绍</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2><a id="_0"></a>本文章由公号【开发小鸽】发布！欢迎关注！！！</h2>
<br>
<p><strong>老规矩–妹妹镇楼：</strong></p>
<center>
<img src="https://img-blog.csdnimg.cn/20200721223424816.JPG" width="20%">
</center><h2><a id="%09_7"></a>一．	接口的定义</h2>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;<strong>接口类似于抽象类，也是定义一些抽象方法，通过实现类来实现这些接口。接口就是一种规范标准，只要符合标准，大家都可以用。</strong><br>
<br></p>
<h2><a id="%09_12"></a>二．	接口的特点</h2>
<br>
<h3><a id="%09interface_15"></a>（一）	接口用关键字interface修饰</h3>
<br>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> 接口名<span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<br>
<h3><a id="%09implements_23"></a>（二）	类实现接口用implements表示</h3>
<br>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 类名 <span class="token keyword">implements</span> 接口名 <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<br>
<h3><a id="%09_31"></a>（三）	接口不能直接实例化</h3>
<br>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;和抽象类一样，接口也不能直接实例化，因为定义了抽象方法。<strong>因此，只有通过实现类实现接口，重写接口中的所有抽象方法，才能将实现类对象实例化。这叫接口多态。</strong><br>
<br></p>
<h3><a id="%09_37"></a>（四）	接口的实现类</h3>
<br>
<ol>
<li>重写接口中的所有抽象方法，能够对象实例化</li>
<li>没有重写接口中的所有抽象方法，依然是<strong>抽象类</strong>。<br>
<br></li>
</ol>
<h2><a id="%09_45"></a>三．	接口的成员特点</h2>
<br>
<h3><a id="%09_48"></a>（一）	接口的成员变量</h3>
<br>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;<strong>接口中的成员变量只能是常量，且默认的修饰符是 public static final</strong>。即如果你仅仅写 int num ，编译器默认添加的修饰符就是public static final int num。<br>
<br></p>
<h3><a id="%09_55"></a>（二）	接口的构造方法</h3>
<br>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;<strong>接口是没有构造方法的，因为接口只是对于行为的抽象，是没有具体的实现的</strong>。那么我们在接口的实现类的构造函数中调用super()为什么不会报错呢？</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;因为，所有类的父类都是Object类，默认继承Object类，因此，调用super()并不会报错。<br>
<br></p>
<h3><a id="%09_63"></a>（三）	接口的成员方法</h3>
<br>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;<strong>接口中的成员方法只能是抽象方法</strong>，就算定义了普通方法，也会添加修饰符定义为抽象方法，<strong>默认修饰符为：public abstract</strong>。<br>
<br></p>
<h2><a id="%09_70"></a>四．	类和接口的关系</h2>
<br>
<h3><a id="_73"></a>（一）类和类的关系</h3>
<br>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;继承关系，<strong>只能单继承</strong>，但是可以<strong>多层继承</strong><br>
<br></p>
<h3><a id="_79"></a>（二）类和接口的关系</h3>
<br>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口<br>
<br></p>
<h3><a id="_86"></a>（三）接口与接口的关系</h3>
<br>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;继承关系，可以单继承，也可以多继承<br>
<br></p>
<h2><a id="%09_93"></a>五．	抽象类和接口的区别</h2>
<br>
<h3><a id="%09_96"></a>（一）	成员的区别</h3>
<br>
<h3><a id="1%09_99"></a>1.	抽象类</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;可以有变量和常量；可以有构造方法；可以有抽象方法，也可以有非抽象方法。</p>
<h4><a id="2%09_102"></a>2.	接口</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;只有常量；没有构造方法；只有抽象方法。<br>
<br></p>
<h3><a id="%09_106"></a>（二）	设计理念区别</h3>
<br>
<h4><a id="1%09_109"></a>1.	抽象类</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;对类进行抽象，一般是行为和属性。</p>
<h4><a id="2%09_112"></a>2.	接口</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;<strong>对行为进行抽象</strong>。<br>
<br></p>
<h2><a id="%09_117"></a>六．	抽象类和接口的案例思考</h2>
<br>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;实现门和警报，如果我们将门和警报都定义在一个抽象类中，是不合适的。<strong>因为门的基本共性是打开和关闭，但是警报功能并不是所有门通用的，因此需要用接口实现警报功能，用抽象类实现门的开合功能。</strong><br>
<br></p>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Alarm</span><span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Door</span><span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlarmDoor</span> <span class="token keyword">extends</span> <span class="token class-name">Door</span> <span class="token keyword">implements</span> <span class="token class-name">Alarm</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div>
</body>

</html>
