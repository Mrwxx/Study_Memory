<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>【Java学习笔记（一）】之继承的基本要点</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2><a id="_0"></a>本文章由公号【开发小鸽】发布！欢迎关注！！！</h2>
<br>
<p><strong>老规矩–妹妹镇楼：</strong></p>
<center>
<img src="https://img-blog.csdnimg.cn/20200721223424816.JPG" width="20%">
</center><h2><a id="%09Java_7"></a>一．	Java继承的特点</h2>
<ol>
<li>
<p>Java只支持单继承，不支持多继承。即一个类只能有一个父类，不能有多个父类。</p>
</li>
<li>
<p>Java支持多层继承。</p>
</li>
</ol>
<br>
<h2><a id="_14"></a>二．继承的格式：</h2>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;通过<strong>extends关键字</strong>，可以声明一个子类继承另外一个父类。格式如下：<br>
<br></p>
<pre><code class="prism language-java"><span class="token keyword">class</span> 父类 <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
<span class="token punctuation">}</span>
<span class="token keyword">class</span> 子类 <span class="token keyword">extends</span> 父类 <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
<span class="token punctuation">}</span>
</code></pre>
<br>
<h2><a id="_28"></a>三．继承中成员变量的访问</h2>
<h3><a id="_29"></a>（一）不重名成员变量的访问</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;如果父类和子类中的成员变量是不重名的，那么对于它们的访问是没有二义性的，直接通过对象调用即可。<br>
<br></p>
<h3><a id="_34"></a>（二）重名成员变量的访问</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;若父类与子类有重名的成员变量，那么在访问时就需要进行区分。<strong>在子类中访问父类中的非私有成员变量时，需要使用super关键字，修饰父类成员变量。而访问子类本身的重名成员变量时，可以用this修饰。</strong></p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;注意：若在子类的成员方法中又定义了<strong>同名的局部变量时，直接用变量名调用</strong>，而子类的重名成员变量用this修饰，父类的重名成员变量用super修饰。</p>
<p>如下所示：<br>
<br></p>
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Fu</span> <span class="token punctuation">{</span>
	<span class="token comment">// Fu中的成员变量。    </span>
	<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Zi</span> <span class="token keyword">extends</span> <span class="token class-name">Fu</span> <span class="token punctuation">{</span>
	<span class="token comment">// Zi中的成员变量    </span>
	<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
	<span class="token comment">//访问父类中的num        </span>
	System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Fu num="</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        
	<span class="token comment">//访问子类中的num        </span>
	System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Zi num="</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        
	<span class="token punctuation">}</span>    
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ExtendsDemo03</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    
       <span class="token comment">// 创建子类对象  </span>
		Zi z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         
       <span class="token comment">// 调用子类中的show方法  </span>
		z<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         
	<span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="_68"></a>四．继承中成员方法的访问</h2>
<h3><a id="_69"></a>（一）不重名成员方法的访问</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;父类和子类的成员方法没有重名，那么可以用对象直接调用成员方法。如在子类对象中调用成员方法，会先在子类中查找有没有对应的方法，若存在就直接执行；若没有，就向上找父类中的方法。<br>
<br></p>
<h3><a id="_73"></a>（二）重名成员方法的访问</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;父类和子类中的成员方法重名，是通过<strong>方法重写</strong>实现的。</p>
<p><strong>&nbsp;  &nbsp;  &nbsp;  &nbsp;方法重写：子类中重新写一个父类中的某一方法（方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。</strong></p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;从名字就可以看出，子类的方法重写对于父类中的重名方法有覆盖效果，若子类对象调用该重写方法，则直接用子类中重写的方法，而不会去调用父类中的重名方法。<br>
<br></p>
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Fu</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Fu show"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
	<span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Zi</span> <span class="token keyword">extends</span> <span class="token class-name">Fu</span> <span class="token punctuation">{</span>
	<span class="token comment">//子类重写了父类的show方法    </span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
		System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Zi show"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
	<span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExtendsDemo05</span><span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    
		Zi z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
      	<span class="token comment">// 子类中有show方法，只执行重写后的show方法   </span>
		z<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Zi show        </span>
	<span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_102"></a>（三）重写的应用</h3>
<p><strong>&nbsp;  &nbsp;  &nbsp;  &nbsp;许多业务是不断更新迭代的，但是我们不能随意更改之前已经上线的业务代码，可以通过定义一个新的类，利用原有业务中的共性内容，并通过重写为新的子类添加新的功能。</strong></p>
<br>
<h2><a id="_107"></a>五．继承中的构造方法</h2>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;子类能够继承父类的成员方法，但是无法继承父类的构造方法，因为构造方法的名字与类名一致。但是我们能够<strong>通过子类调用父类的构造方法。</strong><br>
<br></p>
<h3><a id="super_110"></a>（一）super()</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;<strong>子类构造方法中默认隐含了一个super()调用，调用父类的构造方法，并且仅仅是默认的无参构造函数。即子类在构造时，会先调用父类的无参构造函数，再调用自己的构造函数。</strong><br>
<br></p>
<h3><a id="_114"></a>（二）有参构造函数</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;当父类中定义了有参构造函数，而没有定义无参构造函数时，子类的构造方法就会出错，因为子类只是默认调用了父类的无参构造函数，此时的父类中没有无参构造函数。因此，我们需要<strong>手动定义父类的无参构造函数或者为子类构造函数调用父类的有参构造函数。</strong></p>
</div>
</body>

</html>
