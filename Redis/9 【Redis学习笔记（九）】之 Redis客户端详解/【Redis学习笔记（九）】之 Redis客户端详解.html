<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>【Redis学习笔记（九）】之 Redis客户端详解</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2><a id="_0"></a>本文章由公号【开发小鸽】发布！欢迎关注！！！</h2>
<br>
<p><strong>老规矩–妹妹镇楼：</strong></p>
<center>
<img src="https://img-blog.csdnimg.cn/20200721223424816.JPG" width="20%">
</center><h2><a id="%09_8"></a>一．	客户端</h2>
<h3><a id="%09_10"></a>（一）	概述</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;Redis服务器是典型的一对多服务器程序，通过使用I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，对于每个与服务器连接的客户端都创建了相应的redisClient结构，这个结构保存了客户端当前的状态信息。服务器状态结构的clients属性是一个链表，保存了所有与服务器连接的客户端的状态结构。<br>
<br></p>
<h3><a id="%09_16"></a>（二）	客户端属性</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;客户端状态包含的属性有两类，一类是通用的属性，另一类是特定的属性，如操作数据库用到的db属性等等。<br>
<br></p>
<h4><a id="1%09_22"></a>1.	套接字描述符</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;客户端状态的fd属性记录了客户端正在使用的套接字描述符，有两种类型。一种是伪客户端类型，fd属性为-1，如处理AOF文件或者Lua脚本时产生的伪客户端。另一种是普通客户端，fd属性为大于-1的整数，使用套接字来与服务器通信。使用CLIENT list命令可以列出所有已连接的普通客户端。<br>
<br></p>
<h4><a id="2%09_28"></a>2.	名字</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;默认，连接到服务器的客户端没有名字，通过CLIENT setname命令为客户端设置一个名字，记录在客户端状态的name属性中。</p>
<br>
<h4><a id="3%09_34"></a>3.	标志</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;客户端的标志属性flags记录了客户端的角色，以及目前所处的状态，可以是单个值也可以是多个标志的二进制或。<br>
<br></p>
<h4><a id="4%09_40"></a>4.	输入缓冲区</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;客户端状态的输入缓冲区querybuf属性用于保存客户端发送的命令请求，该区域可以动态扩容，最大不能超过1GB，否则服务器会关闭这个客户端。<br>
<br></p>
<h4><a id="5%09_46"></a>5.	命令与命令参数</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;命令请求保存在querybuf属性后，服务器将对该内容进行分析，将命令参数和命令参数的个数分别保存到客户端状态的argv属性和argc属性中。argv属性是一个数组，每个项都是一个字符串对象，其中的argv[0]是要执行的命令，而之后的其他项是参数。<br>
<br></p>
<h4><a id="6%09_52"></a>6.	命令的实现函数</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;服务器获取命令和参数后，将根据命令的值在命令表中查找命令所对应的命令实现函数，该表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令所对应的redisCommand结构，保存了命令的实现函数结构。当找到命令实现函数时，会将客户端状态的cmd属性指向这个结构，然后就会调用该命令实现了。</p>
<br>
<h4><a id="7%09_57"></a>7.	输出缓冲区</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;执行命令所得到的命令回复会被保存在客户端状态的输出缓冲区中，每个客户端都有两个输出缓冲区，一个是固定大小的保存短字符，一个是可变大小的保存长字符。</p>
<br>
<h4><a id="8%09_62"></a>8.	身份验证</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;客户端状态的authenticated属性用来记录客户端是否通过了身份验证，如果为0表示没有通过，那么除了AUTH验证命令，客户端发送的其他命令都会被服务器拒绝执行。如果为1表示通过了验证，当然这一切都需要服务器开启身份验证功能，否则，服务器不会拒绝客户端的请求。</p>
<br>
<h4><a id="9%09_68"></a>9.	时间</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;ctime: 创建客户端的时间；<br>
&nbsp;  &nbsp;  &nbsp;  &nbsp;lastinteraction: 客户端与服务器最后一个互动时间；<br>
<br></p>
<h3><a id="%09_75"></a>（三）	客户端的创建与关闭</h3>
<h4><a id="1%09_77"></a>1.	创建普通客户端</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;如果客户端是通过网络连接与服务器连接的普通客户端，则在使用connect函数连接到服务器时，服务器会调用连接事件处理器，为客户端创建相应的客户端状态，并添加到服务器状态的clients链表末尾。<br>
<br></p>
<h4><a id="2%09_83"></a>2.	关闭普通客户端</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;可能因为多种原因被关闭，如客户端进程退出或被杀死，发送了不符合协议格式的命令请求，发送的命令请求大小超过了输入缓冲区的限制，命令回复超过了输出缓冲区的限制等等。服务器使用两种模式限制输出缓冲区大小，一种是硬性的，超过了就关闭，另一种是软性限制，如果超过了该大小，但是没有超过硬性限制，且超过的持续时间超过了服务器设定的时长，最后还是要关闭客户端，否则不关闭。<br>
<br></p>
<h4><a id="3%09Lua_89"></a>3.	Lua脚本的伪客户端</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并关联在服务器状态的lua-client属性中，该客户端会在服务器运行周期一直存在，直到服务器关闭。<br>
<br></p>
<h4><a id="4%09AOF_95"></a>4.	AOF文件的伪客户端</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;载入完成之后，会关闭该伪客户端。</p>
</div>
</body>

</html>
