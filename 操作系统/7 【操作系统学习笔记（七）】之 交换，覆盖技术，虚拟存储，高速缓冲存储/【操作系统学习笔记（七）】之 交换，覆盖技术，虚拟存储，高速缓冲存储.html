<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>【操作系统学习笔记（七）】之 交换，覆盖技术，虚拟存储，高速缓冲存储</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p></p><div class="toc"><h3>文章目录</h3><ul><ul><li><a href="#_1">本文章由公号【开发小鸽】发布！欢迎关注！！！</a></li><li><a href="#%09_8">一．	交换技术和覆盖技术</a></li><ul><li><a href="#%09_10">（一）	存储扩容概述</a></li><li><a href="#%09_16">（二）	覆盖技术</a></li><ul><li><a href="#1%09_18">1.	概述</a></li><li><a href="#2%09_24">2.	原理</a></li><li><a href="#3%09_30">3.	优缺点</a></li></ul><li><a href="#%09_36">（三）	交换技术</a></li><ul><li><a href="#1%09_38">1.	原理</a></li><li><a href="#2%09_44">2.	优缺点</a></li></ul></ul><li><a href="#%09_57">二．	虚拟存储</a></li><ul><li><a href="#%09_59">（一）	局部性原理</a></li><ul><li><a href="#1%09_65">1.	时间局部性</a></li><li><a href="#2%09_70">2.	空间局部性</a></li></ul><li><a href="#%09_75">（二）	虚拟存储</a></li><li><a href="#%09_81">（三）	虚拟存储的优势</a></li><li><a href="#%09_89">（四）	虚拟存储的分类</a></li><ul><li><a href="#1%09_91">1.	请求分页</a></li><ul><li><a href="#1%09_92">（1）	概述</a></li><li><a href="#2%09_97">（2）	抖动</a></li><li><a href="#3%09_103">（3）	缺页中断</a></li><li><a href="#4%09_109">（4）	影响缺页的因素</a></li><li><a href="#5%09_117">（5）	多级页表</a></li><li><a href="#6%09_122">（6）	页面调度策略</a></li><li><a href="#7%09_136">（7）	页面淘汰算法</a></li><li><a href="#8%09_148">（8）	常驻集</a></li></ul><li><a href="#2%09_154">2.	请求分段</a></li><li><a href="#3%09_160">3.	请求段页式</a></li></ul></ul><li><a href="#%09_168">三．	高速缓冲存储器</a></li><ul><li><a href="#%09_170">（一）	概述</a></li><li><a href="#%09_176">（二）	组成</a></li><ul><li><a href="#1%09_182">1.	高速缓冲存储器</a></li><li><a href="#2%09_188">2.	缓冲目录</a></li><li><a href="#3%09_194">3.	缓存控制器</a></li></ul><li><a href="#%09_200">（三）	缓存的工作过程</a></li><ul><li><a href="#1%09CPU_202">1.	CPU读数据</a></li><li><a href="#2%09CPU_207">2.	CPU写数据</a></li></ul></ul></ul></ul></div><p></p>
<h2><a id="_1"></a>本文章由公号【开发小鸽】发布！欢迎关注！！！</h2>
<br>
<p><strong>老规矩–妹妹镇楼：</strong></p>
<center>
<img src="https://img-blog.csdnimg.cn/20200721223424816.JPG" width="20%">
</center><h2><a id="%09_8"></a>一．	交换技术和覆盖技术</h2>
<h3><a id="%09_10"></a>（一）	存储扩容概述</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;在基本的存储管理系统中，当一个作业的程序地址空间大于内存可以使用的空间时，该作业就无法装入运行。存储扩容可以解决这个问题，借助大容量的辅存在逻辑上实现内存的扩充，比较常用的存储扩容技术有交换技术和覆盖技术两种。<br>
<br></p>
<h3><a id="%09_16"></a>（二）	覆盖技术</h3>
<h4><a id="1%09_18"></a>1.	概述</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;覆盖技术的目的是在较小的可用内存中运行较大的程序，常用于多道程序系统。</p>
<br>
<h4><a id="2%09_24"></a>2.	原理</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;将程序的必要部分的代码和数据常驻内存，将可选部分在其他程序模块中实现，平时存放在外存中的覆盖文件中，在用到时才会装入到内存中，不存在调用关系的模块之间可以覆盖。<br>
<br></p>
<h4><a id="3%09_30"></a>3.	优缺点</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;有效利用内存，但是在编程时必须划分出程序模块以及它们之间的覆盖关系，同时从外存中装入覆盖文件会消耗更长的时间。<br>
<br></p>
<h3><a id="%09_36"></a>（三）	交换技术</h3>
<h4><a id="1%09_38"></a>1.	原理</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;用于多个程序并发执行的系统中，当某个作业的存储空间不够用时，可以将暂时不执行的程序占用的地址空间交换到外存中，从而获得空闲内存来装入新程序，交换的单位是整个进程的地址空间。</p>
<br>
<h4><a id="2%09_44"></a>2.	优缺点</h4>
<p>优点：<br>
&nbsp;  &nbsp;  &nbsp;  &nbsp;增加并发运行的程序数目；</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;编写程序时不影响结构；</p>
<p>缺点：<br>
&nbsp;  &nbsp;  &nbsp;  &nbsp;换入，换出的控制增加的CPU开销</p>
<br>
<h2><a id="%09_57"></a>二．	虚拟存储</h2>
<h3><a id="%09_59"></a>（一）	局部性原理</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;程序在执行过程中 一个较短时期内，所执行的指令地址和指令的操作数地址分别局限于一定的区域，主要表现为：<br>
<br></p>
<h4><a id="1%09_65"></a>1.	时间局部性</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;一条指令的一次执行和下次执行都集中在一个较短时期内。<br>
<br></p>
<h4><a id="2%09_70"></a>2.	空间局部性</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;当前指令和临近的指令都集中在一个较小的区域中。</p>
<br>
<h3><a id="%09_75"></a>（二）	虚拟存储</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;虚拟存储管理就是基于程序的局部性原理，利用大容量的磁盘作为后备，当作业要占用的内存不够时，将作业的一部分暂时放到磁盘中，当需要时就从磁盘上调入。在程序执行过程中，如果需要执行的指令不在内存中（缺页或缺段），则由系统来调度相应的页或段到内存中，这是请求调入功能，将内存中暂时不用的页或段调出保存在外存中，是置换功能。<br>
<br></p>
<h3><a id="%09_81"></a>（三）	虚拟存储的优势</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;1.	可在较小的内存中执行较大的程序；</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;2.	可在内存中容纳更多程序并发执行；<br>
<br></p>
<h3><a id="%09_89"></a>（四）	虚拟存储的分类</h3>
<h4><a id="1%09_91"></a>1.	请求分页</h4>
<h5><a id="1%09_92"></a>（1）	概述</h5>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;在页式存储的基础之上，增加了请求调页和页面置换的功能，不要求程序一次性全部装入内存之中，只需要装入当前运行的一部分页面，称为工作集，当发现需要的页面不在内存中时，产生缺页中断。为了实现请求分页式存储，需要对页表进行扩展，除了页号和对应的物理块号，还需要添加存在位，用于指示该页是否调入了内存中；添加修改位，表示该页调入内存后是否被修改过。<br>
<br></p>
<h5><a id="2%09_97"></a>（2）	抖动</h5>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;将某一页从内存移到硬盘为出页，从硬盘移到内存为入页。如果刚从内存中移走某个页面后，根据请求马上又调入该页，这种反复进行入页和出页的现象称为抖动，浪费了CPU时间，应尽量避免，产生的主要原因是页面淘汰算法不合理和分配给进程的物理页面数量太少。<br>
<br></p>
<h5><a id="3%09_103"></a>（3）	缺页中断</h5>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;缺页中断是在指令执行期间产生和处理的，而不是在一条指令指令完毕之后，且一条指令的执行可能产生多次缺页中断。<br>
<br></p>
<h5><a id="4%09_109"></a>（4）	影响缺页的因素</h5>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;页面大小，过大则进程使用的大部分地址都在内存中，缺页率低；过小则每个进程的内存页很多，通过调页会适应局部性原理的要求，只有中等情况下，局部性区域只有很小的部分，缺页率高；</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;分配给进程的物理页面数；<br>
<br></p>
<h5><a id="5%09_117"></a>（5）	多级页表</h5>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;如果每页很小，进程页表过长，则可以采用多级页表的形式，每级都可以装入联想存储器中，每一级页表中记录的都是物理页号，指向下级页表或真正被访问的页。<br>
<br></p>
<h5><a id="6%09_122"></a>（6）	页面调度策略</h5>
<p>页面调入策略：<br>
&nbsp;  &nbsp;  &nbsp;  &nbsp;请求调页会产生较多的缺页中断，容易产生抖动；预调页一次调入该页和相邻的几个页，提高IO效率，是基于局部性原理的预测。</p>
<p>页面置换策略：<br>
&nbsp;  &nbsp;  &nbsp;  &nbsp;固定分配局部置换：为每个进程分配固定页数的内存空间，如果出现缺页，则从该进程的页面中进行置换；</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;可变分配全局置换：进程的页数不是固定的，置换的时候所有的页都可以置换；</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;可变分配局部置换：发生缺页时，只允许从该进程的页面中选出一页换出，如果进程频发发生缺页中断，则系统再为该进程分配若干页，直到缺页率降低。<br>
<br></p>
<h5><a id="7%09_136"></a>（7）	页面淘汰算法</h5>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;FIFO：置换建立最早的页；</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;第二次机会淘汰算法（SCR）：按照FIFO选择页面，检查访问位，如果为0则淘汰，否则给第二次机会；</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;页面缓冲算法：对被置换页面进行缓存，便于找到该页；</p>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;最近最少使用算法（LRU）：置换内存中最久未使用的页面，<br>
<br></p>
<h5><a id="8%09_148"></a>（8）	常驻集</h5>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;常驻集指的是虚拟页式管理中给进程分配的物理页面数量。常驻集越小，则内存中的进程越多，并行度越高，但是缺页率也会上升。<br>
<br></p>
<h4><a id="2%09_154"></a>2.	请求分段</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;在段式存储的基础之上，增加了请求调段的功能。<br>
<br></p>
<h4><a id="3%09_160"></a>3.	请求段页式</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;请求分页和请求分段的结合。</p>
<br>
<h2><a id="%09_168"></a>三．	高速缓冲存储器</h2>
<h3><a id="%09_170"></a>（一）	概述</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;高速缓存是为了匹配CPU的处理速率与内存的访问而增加的高速存储器，目的是提高CPU的利用率。<br>
<br></p>
<h3><a id="%09_176"></a>（二）	组成</h3>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;由三部分组成：高速缓冲存储器，缓冲目录，缓冲控制器。</p>
<br>
<h4><a id="1%09_182"></a>1.	高速缓冲存储器</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;分为若干个区，每个区又分为若干个块，每个块用列号标识，因此可以用区号+列号描述每个缓冲存储块。<br>
<br></p>
<h4><a id="2%09_188"></a>2.	缓冲目录</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;描述各个缓冲存储器块的状态，缓冲目录的表项和缓冲存储器块一一对应，每32个缓冲目录的表项构成一行，对应于一个缓冲区。<br>
<br></p>
<h4><a id="3%09_194"></a>3.	缓存控制器</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;负责缓存目录的维护，利用缓存淘汰算法进行缓存的更新。<br>
<br></p>
<h3><a id="%09_200"></a>（三）	缓存的工作过程</h3>
<h4><a id="1%09CPU_202"></a>1.	CPU读数据</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;缓存控制器自动查找缓存目录，确定相应内存数据是否在缓存中，如果在缓存中则读数据，修改访问标志。<br>
<br></p>
<h4><a id="2%09CPU_207"></a>2.	CPU写数据</h4>
<p>&nbsp;  &nbsp;  &nbsp;  &nbsp;地址在缓存中在，则修改缓存内容，设置修改位为1，立即写入内存或等待该缓存快被淘汰时再写入内存中。</p>
</div>
</body>

</html>
